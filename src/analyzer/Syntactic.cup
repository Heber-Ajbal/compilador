package lexical.scanner.mini.c;

//Java Libraries
import java.util.ArrayList;
import java_cup.runtime.Symbol;

parser code {:
    public ArrayList<String> SyntacticErrors = new ArrayList<String>();
    public int count = 0;

    public void syntax_error(Symbol cur_token){
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) cur_token);
        System.out.println("*** Error Sintactico. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
        SyntacticErrors.add("*** Error Sintactico. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
    }

    public void unrecovered_syntax_error(Symbol cur_token){
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) cur_token);
        System.out.println("*** Error Sintactico No Recuperado. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
        SyntacticErrors.add("*** Error Sintactico No Recuperado. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
    }
:}

/* Terminals */
terminal ident, pyc, INT, DOUBLE, BOOL, STRING, OpeningBracket, ClosedBracket,
    OpeningParenthesis, ClosedParenthesis, sVoid, comma, sClass, OpeningCurlyBracket,
    ClosedCurlyBracket, cIf, cElse, lWhile, lFor, sReturn, sBreak, sPrint, assignment,
    sThis, sNew, sNewArray, sReadInteger, sMalloc, dot, sGetByte, sSetByte, sNull,sForeach, sIn,
    sReadLine, integerConstant, doubleConstant, boolConstant, stringConstant,
    ComparisonOperators, equality, negative, sum, ArithmeticOperators, denial,
    Brackets, and, or, Parenthesis, CurlyBrackets, sUsing, namespaceName, sNameSpace,
    sPublic, sPrivate, sProtected, sGet, sSet, sStatic, sVirtual, sOverride,
    sAbstract, colon,sInterface,IncrementOperator,sDo,sTry, sCatch, sFinally,sSwitch, sCase, sDefault,
    sParams, sRef, sOut;

/* Non Terminals */
non terminal Program, ProgramA, Decl, VariableDecl, VariableDeclAux, Variable,InitList,InitListRepeat,ArrayInitializer,
    Type, FunctionDecl, FormalListOpt, RepeatVariable, ClassDecl, ExtClause,
    BaseTypeList, MoreBaseTypes, InterfaceDecl, Prototype, RepeatablePrototype,
    StmtBlock, Stmt, StmtAux, IfStmt, ElseStmt, WhileStmt, ForStmt, ReturnStmt,
    BreakStmt, PrintStmt, Expr, ExprOZ, ExprRepeat, LValue, Call, LibCall,ForeachStmt,
    Actuals, Constant, UsingDirective, NamespaceDecl, RepeatableNamespaceContent,
    PropertyDecl, Accessors, Accessor, AllModifiersOpt, FunctionModifier,NamespacePath,
    MemberDecl, ConstructorDecl, ClassMemberDecls,VariableDeclStmt,ForInit,ForCond,ForIter,DoWhileStmt,TryCatchStmt,
    TryCatchFinallyStmt,CatchBlock,SwitchStmt,SwitchSections,SwitchSection,StmtList,ParamModifierOpt,Param;

/* Precedence */
precedence left assignment;
precedence left or, and;
precedence nonassoc ComparisonOperators, equality;
precedence left sum, negative, ArithmeticOperators;
precedence nonassoc denial;
precedence nonassoc OpeningBracket, dot;
precedence nonassoc cElse;
precedence nonassoc IncrementOperator;

/* Start */
start with Program;

/* Grammar Rules */
Program ::= Decl ProgramA;
ProgramA ::= ProgramA Decl | /* epsilon */;

Decl ::= UsingDirective
       | NamespaceDecl
       | ClassDecl
       | InterfaceDecl
       | MemberDecl
       | error pyc
       | error ClosedCurlyBracket;

UsingDirective ::= sUsing NamespacePath pyc;

NamespacePath ::= ident
                | NamespacePath dot ident;


NamespaceDecl ::= sNameSpace ident OpeningCurlyBracket RepeatableNamespaceContent ClosedCurlyBracket
                | sNameSpace namespaceName OpeningCurlyBracket RepeatableNamespaceContent ClosedCurlyBracket;
RepeatableNamespaceContent ::= RepeatableNamespaceContent Decl | /* epsilon */;

AllModifiersOpt ::= AllModifiersOpt FunctionModifier
                  | sPublic
                  | sPrivate
                  | sProtected
                  | /* epsilon */;

FunctionModifier ::= sStatic | sVirtual | sOverride | sAbstract;

MemberDecl ::= AllModifiersOpt ConstructorDecl
             | AllModifiersOpt FunctionDecl
             | AllModifiersOpt VariableDeclStmt
             | AllModifiersOpt PropertyDecl;

ConstructorDecl ::= ident OpeningParenthesis FormalListOpt ClosedParenthesis StmtBlock;

VariableDeclStmt ::= VariableDecl pyc;

VariableDecl ::= Variable
               | Variable assignment Expr
               | Variable assignment ArrayInitializer;

Variable ::= Type ident;

Type ::= INT | DOUBLE | BOOL | STRING | ident | Type Brackets;

FunctionDecl ::= Type ident OpeningParenthesis FormalListOpt ClosedParenthesis StmtBlock
               | sVoid ident OpeningParenthesis FormalListOpt ClosedParenthesis StmtBlock;

FormalListOpt ::= Param RepeatVariable | /* epsilon */;
RepeatVariable ::= comma Param RepeatVariable | /* epsilon */;

Param ::= ParamModifierOpt Type ident;

ParamModifierOpt ::= sParams
                   | sRef
                   | sOut
                   | /* epsilon */;

ClassDecl ::= sClass ident ExtClause OpeningCurlyBracket ClassMemberDecls ClosedCurlyBracket
            | sClass ident ExtClause CurlyBrackets;

ExtClause ::= colon BaseTypeList | /* epsilon */;
BaseTypeList ::= ident MoreBaseTypes;
MoreBaseTypes ::= comma ident MoreBaseTypes | /* epsilon */;

ClassMemberDecls ::= ClassMemberDecls MemberDecl | /* epsilon */;

InterfaceDecl ::= sInterface ident OpeningCurlyBracket RepeatablePrototype ClosedCurlyBracket
                | sInterface ident CurlyBrackets;
RepeatablePrototype ::= RepeatablePrototype Prototype | /* epsilon */;

Prototype ::= Type ident OpeningParenthesis FormalListOpt ClosedParenthesis pyc
            | sVoid ident OpeningParenthesis FormalListOpt ClosedParenthesis pyc;

StmtBlock ::= OpeningCurlyBracket VariableDeclAux StmtAux ClosedCurlyBracket
            | CurlyBrackets;

VariableDeclAux ::= VariableDeclAux VariableDeclStmt | /* epsilon */;
StmtAux ::= Stmt StmtAux | /* epsilon */;

Stmt ::= Expr pyc
       | pyc
       | IfStmt
       | WhileStmt
       | ForStmt
       | BreakStmt
       | ReturnStmt
       | PrintStmt
       | StmtBlock
       | TryCatchStmt
       | TryCatchFinallyStmt
       | SwitchStmt
       | ForeachStmt
       | DoWhileStmt;

ExprOZ ::= Expr | /* epsilon */;

IfStmt ::= cIf OpeningParenthesis Expr ClosedParenthesis Stmt ElseStmt;
ElseStmt ::= cElse Stmt | /* epsilon */;
WhileStmt ::= lWhile OpeningParenthesis Expr ClosedParenthesis Stmt;
DoWhileStmt ::= sDo Stmt lWhile OpeningParenthesis Expr ClosedParenthesis pyc;

ForeachStmt ::= sForeach OpeningParenthesis Type ident sIn Expr ClosedParenthesis StmtBlock;

TryCatchStmt ::= sTry StmtBlock CatchBlock;

TryCatchFinallyStmt ::= sTry StmtBlock CatchBlock sFinally StmtBlock;

CatchBlock ::= sCatch OpeningParenthesis Type ident ClosedParenthesis StmtBlock;

SwitchStmt ::= sSwitch OpeningParenthesis Expr ClosedParenthesis OpeningCurlyBracket SwitchSections ClosedCurlyBracket;

SwitchSections ::= SwitchSections SwitchSection | /* epsilon */;

SwitchSection ::= sCase Constant colon StmtList
                | sDefault colon StmtList;

StmtList ::= Stmt StmtList | /* epsilon */;

/* For estrictamente válido: no permite vacío */
ForInit ::= VariableDecl
          | Expr;

ForCond ::= Expr;
ForIter ::= Expr;

ForStmt ::= lFor OpeningParenthesis ForInit pyc ForCond pyc ForIter ClosedParenthesis Stmt;

ReturnStmt ::= sReturn ExprOZ pyc;
BreakStmt ::= sBreak pyc;

PrintStmt ::= sPrint OpeningParenthesis Expr ExprRepeat ClosedParenthesis pyc;
ExprRepeat ::= comma Expr ExprRepeat | /* epsilon */;

Expr ::= LValue assignment Expr
       | Constant
       | LValue
       | sThis
       | Call
       | OpeningParenthesis Expr ClosedParenthesis
       | Expr ArithmeticOperators Expr
       | Expr sum Expr
       | Expr negative Expr
       | Expr and Expr
       | Expr or Expr
       | Expr equality Expr
       | Expr ComparisonOperators Expr
       | negative Expr
       | denial Expr
       | sNew OpeningParenthesis ident ClosedParenthesis
       | sNewArray OpeningParenthesis Expr comma Type ClosedParenthesis
       | sReadInteger Parenthesis
       | sReadLine Parenthesis
       | sMalloc OpeningParenthesis Expr ClosedParenthesis
       | IncrementOperator Expr      // ++i
       | Expr IncrementOperator
       |sNew Type OpeningBracket Expr ClosedBracket;

ArrayInitializer ::= OpeningCurlyBracket InitList ClosedCurlyBracket;
InitList ::= Expr InitListRepeat | /* vacío */;
InitListRepeat ::= comma Expr InitListRepeat | /* vacío */;

LValue ::= ident
         | Expr dot ident
         | Expr OpeningBracket Expr ClosedBracket;

Call ::= ident OpeningParenthesis Actuals ClosedParenthesis
       | ident Parenthesis
       | Expr dot ident OpeningParenthesis Actuals ClosedParenthesis
       | Expr dot ident Parenthesis
       | Expr dot LibCall OpeningParenthesis Actuals ClosedParenthesis
       | Expr dot LibCall Parenthesis;

LibCall ::= sGetByte OpeningParenthesis Expr ClosedParenthesis
          | sSetByte OpeningParenthesis Expr comma Expr ClosedParenthesis;

Actuals ::= Expr ExprRepeat | /* epsilon */;

Constant ::= integerConstant
           | doubleConstant
           | boolConstant
           | stringConstant
           | sNull;

PropertyDecl ::= Type ident OpeningCurlyBracket Accessors ClosedCurlyBracket;
Accessors ::= Accessor Accessors | Accessor;
Accessor ::= sGet StmtBlock
           | sSet StmtBlock
           | sGet pyc
           | sSet pyc;
